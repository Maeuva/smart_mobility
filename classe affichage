class Affichage(tk.Tk):
    def __init__(self, graph, route):
        super().__init__()
        self.graph = graph
        self.route = route
        
        self.title("Groupe Audrey Maeva Kanelle")

        # appuyer sur la touche echap pour fermer le programme
        self.bind_all("<Escape>", self.fermer)
        # appuyer sur la touche M pour afficher la matrice de cout
        self.bind_all("<m>", self.afficher_matrice)
        # Forcer le focus sur la fenêtre principale
        self.focus_force()

        # Canvas pour dessiner
        self.canvas = tk.Canvas(self, width=LARGEUR, height=HAUTEUR, bg="white")
        self.canvas.pack()

        # Affichage des points et de la route
        self.afficher_route(self.change_route())
        self.afficher_points(self.change_route())

        # zone d'affichage de la matrice de cout
        self.label_matrice = tk.Label(self, text="", anchor="w")
        self.label_matrice.pack(pady=10)

        # zone d'affichage du nombre d'iteration et de la meilleur distance
        self.label_info = tk.Label(self, anchor="w", justify="left")
        self.label_info.pack(pady=10)

    def change_route(self):
        lieux_dict = {lieu.nom: (lieu.x, lieu.y, lieu.nom) for lieu in self.graph.liste_lieux}
        route_heuristique = [lieux_dict[num] for num in self.route.ordre]
        return route_heuristique

    def fermer(self, event=None):
        print("ESC press detected! Closing window.")  # Debug print
        self.destroy()

    def afficher_points(self, route_points):
        # Affiche chaque point de la route comme un cercle avec son numéro
        for i, (x, y, nom) in enumerate(route_points):
            if nom == 0:
                # Cercle pour le point
                self.canvas.create_oval(
                    x - RAYON, y - RAYON,
                    x + RAYON, y + RAYON,
                    fill="red", outline="black"
                )
            else:
                # Cercle pour le point
                self.canvas.create_oval(
                    x - RAYON, y - RAYON,
                    x + RAYON, y + RAYON,
                    fill="lightgrey", outline="black"
                )

            # Affiche le numéro du point
            self.canvas.create_text(x, y, text=str(nom), fill="black")
            # Affiche l'ordre de passage du point
            self.canvas.create_text(x, y - 30, text=str(i), fill="black")

    def afficher_route(self, route_points):
        # Trace les lignes entre les points de la route
        print("texte",route_points)
        for i in range(len(route_points) - 1):
            x1, y1 = route_points[i][0], route_points[i][1]
            x2, y2 = route_points[i + 1][0], route_points[i + 1][1],
            print(x1, x2, y1, y2)
            self.canvas.create_line(x1, y1, x2, y2, fill="blue", dash=(5, 2))

        # Relie le dernier point au premier pour fermer la route
        x1, y1 = route_points[-1][0], route_points[-1][1]
        x2, y2 = route_points[0][0], route_points[0][1]
        self.canvas.create_line(x1, y1, x2, y2, fill="blue", dash=(5, 2))

    def afficher_matrice(self, event=None):
        # Convertir la matrice en texte pour l'affichage
        matrice_texte = "\n".join(["\t".join(map(str, ligne)) for ligne in self.graph.matrice_cout_od])
        self.label_matrice.config(text=matrice_texte)  # Afficher dans le label
 
    def mettre_a_jour_label_info(self):
       # Met à jour le label avec un seul texte sans accumulation
       self.label_info.config(text = "La distance est : " + str(self.route.distance) + " pour "+str(10) + " itérations") 
    
    def run(self):
        self.mettre_a_jour_label_info()
        self.mainloop()

